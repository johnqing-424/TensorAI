问题排查与修复的思维模板
1. 观察现象，明确问题范围
现象: TensorAI 项目在 withref 分支无法显示引用标记和参考文档列表，而功能相似的 ragflow 项目可以。
初步假设: 后端 API 大概率是正常的，因为两个项目共用。问题很可能出在 TensorAI 的前端代码中，具体范围在“从接收后端数据”到“在 UI 上渲染”的整个链条。
2. 验证数据源头：网络请求是否收到了正确的数据？
行动: 打开浏览器开发者工具（F12），切换到“网络(Network)”和“控制台(Console)”面板，然后复现问题。
关键发现 (来自您提供的日志):
在控制台日志中，我看到了 client.ts 文件打印出的 accumulatedReference 对象。
这个对象内部清晰地包含了 chunks 和 doc_aggs 数组，证明数据流已经成功从后端抵达了浏览器。
结论: 问题不在于网络请求本身，而在于前端代码如何处理和传递这些收到的流式数据。问题范围被缩小到 api/client.ts 内部的数据处理逻辑，以及它与上层 ChatContext 的交互。
3. 追踪数据流：数据在代码中是如何传递，在哪里“变质”的？
数据流路径: api/client.ts (接收和初步处理) -> ChatContext.tsx (状态管理) -> MessageContent.tsx & MarkdownRenderer.tsx (UI渲染)。
行动: 沿着这条路径，在关键节点打印日志，观察数据对象的变化。
关键发现 (来自您提供的日志):
api/client.ts: 日志显示，虽然 accumulatedReference 在累积，但它似乎在数据流的某个时刻被一个空的 reference 对象（如 {chunks: []}）覆盖了。
ChatContext.tsx: 日志显示，从 apiClient 传递过来的引用数据结构不正确，数组变成了数字 0 ({total: 0, doc_aggs: 0, chunks: 0}), 这说明数据在向上传递时已被破坏。
MessageContent.tsx: 日志显示，组件渲染时 reference 属性是 undefined，这解释了为何 UI 上什么都没有。
结论: “犯罪现场”基本锁定在 api/client.ts 的 streamChatMessage 函数中。它的逻辑未能正确地“累积”数据，导致不完整的、甚至是错误的数据被传递给了 ChatContext。
4. 精准定位并修复 Bug
分析 streamChatMessage 的逻辑:
根本错误: 该函数没有正确处理 SSE (Server-Sent Events) 流的特性。流式响应会将一个完整的引用信息拆分成多个数据块发送。旧逻辑在每次收到新数据块时，不是将新的 chunks 和 doc_aggs 添加到已有的集合中，而是直接用新数据块中的 reference 对象覆盖了整个累积的 accumulatedReference 变量。如果某个数据块不包含 reference 或者包含一个空的 reference，就会导致之前累积的数据全部丢失。
次要错误:
类型错误: 代码中误用了 chunk_id 来访问 ReferenceChunk 的唯一标识，而正确的属性名其实是 id。
空指针风险: 在初始化 accumulatedReference 变量之前就尝试读取它的属性（如 .chunks），这在 TypeScript 中会引发 "possibly 'null'" 错误。
最终修复方案:
正确累积: 确保在处理新的数据块时，是将 newRef.chunks 和 newRef.doc_aggs 合并到 accumulatedReference 中，而不是替换它。使用 Set 来存储已有的 ID，可以高效地防止重复添加。
安全初始化: 在任何读写操作之前，先检查 accumulatedReference 是否为 null，如果为 null，则立即创建一个包含空数组的初始对象 { chunks: [], doc_aggs: [], total: 0 }。
修正类型: 将所有 .chunk_id 的访问全部修正为 .id。
持续传递: 在每次调用 onChunkReceived 回调时，都传递当前完整累积的 accumulatedReference 对象，而不是原始数据块中的 reference。
这就是我完整的问题分析与解决思路。核心在于自下而上地追踪数据流，从网络层到UI层，通过日志观察数据在每一步的变化，最终精准定位到发生问题的代码逻辑。